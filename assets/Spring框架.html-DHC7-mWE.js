import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as n,o as l}from"./app-Ajq5bhoz.js";const t={};function e(h,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="spring-框架" tabindex="-1"><a class="header-anchor" href="#spring-框架"><span>Spring 框架</span></a></h1><h2 id="正射与反射" tabindex="-1"><a class="header-anchor" href="#正射与反射"><span>正射与反射</span></a></h2><hr><h3 id="正射与反射的概述" tabindex="-1"><a class="header-anchor" href="#正射与反射的概述"><span>正射与反射的概述</span></a></h3><ul><li>正射：正射就是在运行时就知道要操作的类是什么，并且可以使用 new 关键字来创建对象。</li><li>反射：反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 <ul><li>优点： <ol><li>在程序运⾏过程中可以操作类对象，增加了程序的灵活性。</li><li>解耦，从而提高程序的可扩展性，提高代码的复用率，⽅便外部调用。</li><li>对于任何⼀个类，当知道它的类名后，就能够知道这个类的所有属性和⽅法；⽽对于任何⼀个对象，都能够调⽤它的⼀个任意⽅法。</li></ol></li><li>缺点： <ol><li>性能问题：Java 反射中包含了⼀些动态类型，JVM ⽆法对这些动态代码进⾏优化，因此通过反射来操作的⽅式要⽐正常操作效率更低。</li><li>安全问题：使⽤反射时要求程序必须在⼀个没有安全限制的环境中运⾏，如果程序有安全限制，就不能使用反射。</li><li>程序健壮性：反射允许代码执⾏⼀些平常不被允许的操作，破坏了程序结构的抽象性，导致平台发⽣变化时抽象的逻辑结构⽆法被识别。</li></ol></li></ul></li></ul><h3 id="正射与反射创建对象的方法" tabindex="-1"><a class="header-anchor" href="#正射与反射创建对象的方法"><span>正射与反射创建对象的方法</span></a></h3><ol><li><p>正射：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Apple</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> apple </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Apple</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //调用默认构造函数直接初始化对象</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setPrice</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>反射：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz  </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;com.javaee.reflect.Apple&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Constructor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConstructor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		//获取构造函数</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> object </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> constructor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		//创建一个对象</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Method</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> method </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;setPrice&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		//获取对象的方法</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">invoke</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(object, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">		//调用方法并传入函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两段代码的执行结果是完全一样的，但其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类(Apple)，而第二段代码则是在运行时通过字符串值才得知要运行的类(com.javaee.reflect.Apple)。</p></li></ol><h3 id="反射常用的-api" tabindex="-1"><a class="header-anchor" href="#反射常用的-api"><span>反射常用的 API</span></a></h3><ol><li><p>获取反射中的 Class 对象</p><ol><li><p><em><strong>Class.forName()</strong></em> 静态方法：当你知道该类的全路径名时，你可以使用该方法获取<em>Class</em>类对象</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz  </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;com.javaee.reflect.Apple&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>使用.class方法</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz  </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>使用类对象的 <em><strong>getClass()</strong></em> 方法</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Apple</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> apple </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;红富士&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p>通过反射创建类对象</p><ol><li><p>通过 <em>Class</em> 对象的 <em><strong>newInstance()</strong></em> 方法</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz  </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Apple</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> apple </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (Apple) </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过 <em>Constructor</em> 对象的 <em><strong>newInstance()</strong></em> 方法</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Constructor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConstructor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Apple</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> apple </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (Apple)</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">constructor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>通过 <em>Constructor</em> 对象创建类对象可以选择特点构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。以下为例子</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Constructor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> constructor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConstructor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Apple</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> apple </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (Apple)</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">constructor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;红富士&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">15</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过反射获取类属性方法及构造器</p><ol><li><p>通过 <em>Class</em> 对象的 <em><strong>getFields()</strong></em> 方法：可以获取 Class 类的属性，但无法获取私有属性。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Field</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] fields </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getFields</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Field</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> field </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fields){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">	System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//输出结果为 price</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过 <em>Class</em> 对象的 <em><strong>getDeclaredFields()</strong></em> 方法：可以获取包括私有属性在内的所有属性。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> clz </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Apple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Field</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] fields </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> clz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getDeclaredFields</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Field</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> field </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fields){</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">	System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//输出结果为 name price</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 <em><strong><u>declared</u></strong></em> 关键字的方法。</p></li></ol><h2 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式"><span>单例模式</span></a></h2><hr><h3 id="单例模式的概述" tabindex="-1"><a class="header-anchor" href="#单例模式的概述"><span>单例模式的概述</span></a></h3><ul><li><p><em><strong>单例模式是指在内存中只会创建且仅创建⼀次对象的设计模式</strong></em>。在程序中<em><strong>多次使用同⼀个对象且作⽤相同</strong></em> 时，为了防⽌频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<em><strong>创建⼀个对象</strong></em>，让所有需要调⽤的地⽅都共享 这⼀单例对象。</p><figure><img src="http://101.43.49.28:9000/blog/单例模式的概述.png" alt="单例模式的概述" tabindex="0" loading="lazy"><figcaption>单例模式的概述</figcaption></figure></li><li><p>如何保证对象的唯一性</p><ol><li>不允许其他程序⽤ new ⽅法创建对象 <em><strong>(构造函数私有化)</strong></em>。</li><li>在该类中创建对象—在类内部代码中实现对象创建。</li><li>对外提供⼀个可以让其他程序获取该对象的⽅法 <em><strong>(提供⼀个静态方法的接口给外部调用)</strong></em>。</li></ol></li></ul><h3 id="单例模式的实现方法" tabindex="-1"><a class="header-anchor" href="#单例模式的实现方法"><span>单例模式的实现方法</span></a></h3><h4 id="懒汉式" tabindex="-1"><a class="header-anchor" href="#懒汉式"><span>懒汉式：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BasicSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      /*使用静态变量*/</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BasicSingleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      /*构造函数私有化,禁止使用new 创建对象*/</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      private</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BasicSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(){}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      /*提供静态的获取实例的接口 */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BasicSingleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">          if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){      </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 这里线程是不安全的,可能得到两个不同的实例</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">             instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BasicSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">          }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">          return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      /*测试方法*/</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]  </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">          BasicSingleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> BasicSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">          BasicSingleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> BasicSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">          System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;懒汉式：instance1和instance2是否相等:&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (instance1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> instance2));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>上述代码的缺点：</p><p>如果两个线程同时判断 singleton 为空，那么它们都会去实例化⼀个 Singleton 对象，这就变成双例了，要解决的是<em><strong>线程安全</strong></em>问题。</p><ul><li><p>解决方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BasicSingleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {        </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">BasicSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {        </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 线程A或线程B获得该锁进⾏初始化</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {        </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 其中⼀个线程进⼊该分⽀，另外⼀个线程则不会进⼊该分⽀</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> BasicSingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上⾯的代码已经完美地解决了<em><strong>并发安全+性能低效</strong></em> 问题：</p><ol><li>第2行代码，如果 singleton 不为空，则直接返回对象，不需要获取锁；而如果多个线程发现 singleton 为空， 则进⼊分⽀。</li><li>第3行代码，多个线程尝试争抢同⼀个锁，只有⼀个线程争抢成功，第⼀个获取到锁的线程会再次判断 singleton 是否为空，因为 singleton 有可能已经被之前的线程实例化。</li><li>其它之后获取到锁的线程在执行到第4行校验代码，发现 singleton 已经不为空了，则不会再 new 一个对象，直接返回对象即可</li><li>之后所有进⼊该方法的线程都不会去获取锁，在第⼀次判断 singleton 对象时已经不为空了</li></ol><p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：<em><strong>Double Check（双重校验） + Lock（加锁）</strong></em></p><hr><p>但还有一个问题：<em><strong>指令重排</strong></em></p><ul><li><p>指令重排序是指：JVM 在保证最终结果正确的情况下，可以不按照程序编码的顺序执⾏语句，尽可能提高程序的性能。</p></li><li><p>解决方法：使⽤ <u><em><strong>volatile</strong></em></u> 关键字修饰的变量，可以保证其指令执⾏的顺序与程序指明的顺序⼀致，不会发⽣顺序变换，这样在多线程环境下就不会发⽣ NPE 异常，如下列代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BasicSingleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul></li></ul><h4 id="饿汉式" tabindex="-1"><a class="header-anchor" href="#饿汉式"><span>饿汉式：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HungrySingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	private</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> HungrySingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(){}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          //1.单例模式的饿汉式[可用]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HungrySingleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> HungrySingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	///提供静态的获取实例的接口 </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> HungrySingleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">		return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	//测试方法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">	public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">		HungrySingleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> HungrySingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">		HungrySingleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> HungrySingleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">		System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;饿汉式：instance1和instance2是否相等:&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(instance1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> instance2));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>优点：从它的实现中我们可以看到，这种⽅式的实现⽐较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。</li><li>缺点：由于在类加载的时候就实例化了，所以没有达到 <em><strong>Lazy Loading(懒加载)</strong></em> 的效果，也就是说可能我没有⽤到这个实例，但是它也会加载，会造成内存的浪费(但是这个浪费可以忽略，所以这种⽅式也是推荐使⽤的)。</li></ul><h3 id="单例模式的总结" tabindex="-1"><a class="header-anchor" href="#单例模式的总结"><span>单例模式的总结</span></a></h3><ol><li>单例模式有两种：懒汉式、饿汉式</li><li>懒汉式：在需要⽤到对象时才实例化对象，正确的实现⽅式是：<em><strong>Double Check + Lock</strong></em>，解决了并发安全和性能低下问题。</li><li>饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</li><li>在开发中如果对<em>内存要求非常高</em>，那么使⽤懒汉式写法，可以在特定时候才创建该对象。</li><li>如果对内存要求不⾼使⽤饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题。</li><li>为了防⽌多线程环境下，因为指令重排序导致变量报 NPE，<em><strong>需要在单例对象上添加<u>volatile</u>关键字防⽌指令重排序</strong></em>。</li></ol><h2 id="spring-框架-1" tabindex="-1"><a class="header-anchor" href="#spring-框架-1"><span>Spring 框架</span></a></h2><hr><h3 id="spring-的概述" tabindex="-1"><a class="header-anchor" href="#spring-的概述"><span>Spring 的概述</span></a></h3><p>​ <em><strong>Spring</strong></em>是分层的<em><strong>JavaSE/EE full-stack</strong></em> 轻量级开源框架，以 <em><strong>IoC（Inverse of Control 控制反转）</strong></em> 和 <em><strong>AOP（Aspect Oriented Programming 面向切面编程）</strong></em> 为内核，使用基本的 JavaBean 来完成以前只可能由 EJB 完成的工作，取代了 <em><strong>EJB</strong></em> 的臃肿、低效的开发模式。</p><h3 id="spring-的框架" tabindex="-1"><a class="header-anchor" href="#spring-的框架"><span>Spring 的框架</span></a></h3><p>​ 在实际开发中，通常服务器端在采用三层体系架构，分别为<em><strong>表示层(web)</strong></em>、<em><strong>控制层（Control）</strong></em>、<em><strong>业务逻辑层(service)</strong></em>、<em><strong>持久层(dao)</strong></em>， Spring 对每一层都提供了技术支持。</p><figure><img src="http://101.43.49.28:9000/blog/Spring的框架.png" alt="Spring 的框架" tabindex="0" loading="lazy"><figcaption>Spring 的框架</figcaption></figure><h3 id="控制反转-inverse-of-control-和依赖注入-di" tabindex="-1"><a class="header-anchor" href="#控制反转-inverse-of-control-和依赖注入-di"><span>控制反转(Inverse Of Control)和依赖注入(DI）</span></a></h3><ul><li><p>控制反转（ Inverse Of Control ）:<strong>对象的创建交给外部容器完成</strong>。不直接在代码中创建对象。控制反转解决对象的管理（创建、销毁等）问题。</p></li><li><p>依赖注入（dependency injection）:<strong>实现对象之间的依赖关系。</strong> 在创建完对象之后，对象之间的关系处理就是依赖注入。</p><figure><img src="http://101.43.49.28:9000/blog/依赖注入例子.png" alt="依赖注入例子" tabindex="0" loading="lazy"><figcaption>依赖注入例子</figcaption></figure></li></ul><p>注意：Spring 提供了 IOC 容器。无论创建对象、处理对象之间的依赖关系、对象创建的时间还是数量，都在 <em><strong>Spring IOC 容器</strong></em>配置完成。</p><h4 id="控制反转-inverse-of-control" tabindex="-1"><a class="header-anchor" href="#控制反转-inverse-of-control"><span>控制反转(Inverse Of Control)</span></a></h4><ul><li><p>IOC 核心思想：资源不由资源的使用方管理，而由不使用资源的第三方管理。</p><p>优点：</p><ol><li>资源集中管理，实现资源的可配置和易管理；</li><li>降低使用资源双方的依赖程度。</li></ol></li><li><p>IOC 实现原理：</p><ol><li>Java 反射技术。</li><li>解析 XML 文件。</li><li>单例设计模式或工厂设计模式。</li></ol></li><li><p>IOC 工作过程</p><figure><img src="http://101.43.49.28:9000/blog/IOC工作过程.png" alt="IOC 工作过程" tabindex="0" loading="lazy"><figcaption>IOC 工作过程</figcaption></figure></li></ul><h3 id="bean" tabindex="-1"><a class="header-anchor" href="#bean"><span>Bean</span></a></h3><h4 id="bean-的概述" tabindex="-1"><a class="header-anchor" href="#bean-的概述"><span>Bean 的概述：</span></a></h4><p>​ 如果把 Spring 看做一个大型的工厂，而 Spring 容器中的 Bean 就是该工厂的产品。要想使用这个工厂生产和管理 Bean，就需要在配置文件中告诉它需要哪些 Bean，以及需要使用何种方式将这些 Bean 装配到一起。</p><h4 id="bean的三种装配方式" tabindex="-1"><a class="header-anchor" href="#bean的三种装配方式"><span>Bean的三种装配方式</span></a></h4><ol><li><em><strong>基于 XML 装配 Bean</strong></em> -- 容易理解，但是使用繁琐</li><li><em><strong>基于自动扫描和注解装配 Bean</strong></em> -- 减少XML文件配置</li><li><em><strong>基于 JavaConfig 装配 Bean</strong></em> -- 实现零配置，不需要XML文件</li></ol><p>Spring 容器支持两种格式的配置文件：<em><strong>Properties 文件</strong></em>、<em><strong>XML 文件</strong></em></p><p>下图为 Bean 在 XML 文件下的配置文件：</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">beans</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> xmlns</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">       xmlns:xsi</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">       xsi:schemaLocation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;http://www.springframework.org/schema/beans </span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">       	http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	&lt;!-- 使用id属性定义bean1,其对应的实现类为cn.itcast.bean1 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;bean1&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;cn.itcast.bean1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	&lt;!-- 使用name属性定义bean2,其对应的实现类为cn.itcast.bean2 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;bean2&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;cn.itcast.bean2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">	&lt;!-- 注意如果在Bean中未指定id和name，则Spring会将class值当作id使用。 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">beans</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际开发中，<em><strong>最常使用的是 XML 文件格式</strong></em>的配置方式，这种配置方式是通过 XML 文件来注册并管理 Bean 之间的依赖关系。</p><h4 id="bean-的实例化" tabindex="-1"><a class="header-anchor" href="#bean-的实例化"><span>Bean 的实例化</span></a></h4><p>​ 在面向对象的程序中，要想使用某个对象，就需要先实例化这个对象。在 Spring 中，<em><strong>实例化 Bean</strong></em>有三种方式，分别为<em><strong>构造器</strong></em>实例化、<em><strong>静态工厂方式</strong></em>实例化和<em><strong>实例工厂方式</strong></em>实例化，接下来对这三种方式分别进行讲解。</p><h4 id="bean-的作用域" tabindex="-1"><a class="header-anchor" href="#bean-的作用域"><span>Bean 的作用域</span></a></h4><p>​ Singleton 作用域：Singleton 作用域是 Spring 容器默认的作用域，当一个 bean 的作用域为 singleton 时，Spring 容器中只会存在一个共享的 Bean 实例，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配的，就只会返回 Bean 的同一个实例。</p><ul><li><p>注意：在 Spring 配置文件中，可以使用 bean 元素的 scope 属性，将 Bean 的作用域定义成 singleton。</p><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bean</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;cn.itcast.hello.Hello&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> scope</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;singleton&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h4 id="bean的装配方式" tabindex="-1"><a class="header-anchor" href="#bean的装配方式"><span>Bean的装配方式</span></a></h4><ul><li><p><em><strong>Bean 的装配</strong></em>可以理解为依赖关系注入，<em><strong>Bean 的装配方式即 Bean 依赖注入的方式</strong></em>。Spring 容器支持多种形式的 Bean 的装配方式，如基于 XML 的装配、基于 Annotation 的装配和自动装配等。</p><ol><li><p>基于 XML 的装配</p><ul><li><p>Spring 依赖注入有两种方式：1.<em><strong>设值注入(Setter Injection)</strong></em> 2.<em><strong>构造注入(Constructor Injection)</strong></em></p><ol><li><p>设值注入(Setter Injection):</p><p>设值注入要求一个 Bean 必须满足以下两点要求：</p><ol><li>Bean 类必须提供一个默认的构造方法。</li><li>Bean 类必须为需要注入的属性提供对应的set方法。</li></ol><p>使用设值注入时，在 Spring 配置文件中，需要使用 <em><strong>&lt;bean&gt;</strong></em> 元素的子元素 <em><strong>&lt;property&gt;</strong></em> 元素来为每个属性注入值。</p></li><li><p>构造注入(Constructor Injection):</p><p>使用构造注入时，在配置文件里，主要是使用 <em><strong>&lt;constructor-arg&gt;</strong></em> 标签来定义构造方法的参数，可以使用其 <em><strong>value</strong></em> 属性（或 <em><strong>子元素</strong></em> ）来设置该参数的值。</p></li></ol></li></ul></li><li><p>基于 Annotation 的装配</p><ul><li><p>概述：在 Spring 中，尽管使用XML配置文件可以实现 Bean 的装配工作，但如果应用中有很多 Bean 时，会导致XML配置文件过于臃肿，给后续的维护和升级工作带来一定的困难。为此，Java 从 <em><strong>JDK1.5</strong></em> 以后，提供了 <em><strong>Annotation（注解）<em><strong>功能，Spring 也提供了对 Annotation 技术的</strong></em>全面支持</strong></em>。</p></li><li><p>注解的工作原理</p><ol><li><p>注解的格式：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> 注解名称</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">{ </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">	属性列表</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>注解分类： <em><strong>自定义注解</strong></em>、<em><strong>JDK 内置注解</strong></em>、<em><strong>第三方框架提供的注解</strong></em>。</p></li><li><p>使用位置： 类、方法、成员变量、型参位置等。</p></li><li><p>作用：注释事写给程序员看的，注解是写给程序看的。<strong>目的是为当前读取注解的程序提供判断依据。</strong></p></li><li><p>自定义注释</p><p>例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Target</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">({</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ElementType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">FIELD</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ElementType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">METHOD</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Retention</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RetentionPolicy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">RUNTIME</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 定义注解Properly</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> @</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;"> MyProperty</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">{ </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">	Public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">default</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;小白&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>注解类型是通过“<em><strong>@interface</strong></em>”关键字定义。</li><li>注解返回值类型：原始数据类型、String、Class 类型、枚举类型等，可以指定默认返回值。</li><li>注解的使用：<em><strong>定义注解</strong></em>、<em><strong>使用注解</strong></em>、<em><strong>读取注解</strong></em>。</li><li>上面注解表示：<em><strong>@Target</strong></em>表示注解使用的地方为属性或者方法；<em><strong>@Rentention</strong></em>表示注解在运行时被解析；同时，该注解包含一个名称为 value 的属性，类型为 String，存在默认值。</li></ol></li><li><p>注解的解析</p><ol><li><p>编译时解析。 使用 <em><strong>@Rentention</strong></em> 的值为 CLASS 的注解，要解析该类注解，需要完成两个步骤：</p><ol><li>自定义一个派生自 AbstractProccessor 的注解处理类。</li><li>重写 process 函数。</li></ol></li><li><p>运行时注解解析。指 <em><strong>@Rentention</strong></em> 的值为 RUNTIME 的注解。通过反射机制在运行时解析定义的注解。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">T</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getAnnotation</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> annotationClass) </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//返回该程序元素的指定类型的注解</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol></li><li><p>Spring常用注解</p><table><thead><tr><th>注解名</th><th>作用</th></tr></thead><tbody><tr><td>@Component</td><td>装配一个Bean对象，用在相应类上。</td></tr><tr><td>@Autowired</td><td>属性注入，将Bean对象注入到另一个对象的属性。</td></tr><tr><td>@Repository</td><td>用于将数据访问层 (DAO 层 ) 的类标识为Spring中的Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service</td><td>通常作用在业务层（Service层），用于将业务层的类标识为Spring中的Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller</td><td>通常作用在控制层（如Struts2的Action），用于将控制层的类标识为Spring中的Bean，其功能与 @Component 相同。</td></tr><tr><td>@Autowired</td><td>用于对Bean的属性变量、属性的Set方法及构造函数进行标注，配合对应的注解处理器完成Bean的自动配置工作。默认按照Bean的类型进行装配。</td></tr><tr><td>@ComponentScan</td><td>定义扫描的路径。</td></tr><tr><td>@Configuration</td><td>注解标注当前类为配置类，该类作为Spring的XML配置文件&lt;beans&gt;</td></tr><tr><td>@Bean</td><td>用在方法上，将返回值装配为Bean对象。</td></tr><tr><td>@Qualifier</td><td>用于消除自动装配Bean时的歧义。当多个类型相同的 Bean 可以注入到目标 Bean 中时，可以使用 @Qualifier 注解指定要注入的Bean</td></tr></tbody></table></li></ol></li></ul></li></ol></li></ul><h3 id="依赖注入-di" tabindex="-1"><a class="header-anchor" href="#依赖注入-di"><span>依赖注入(DI)</span></a></h3><p>依赖注入存在三种实现方式，分别是 <em><strong>setter 方法注入</strong></em>、<em><strong>构造方法注入</strong></em>和<em><strong>接口注入</strong></em>。</p><figure><img src="http://101.43.49.28:9000/blog/依赖注入的实现方式.png" alt="依赖注入的实现方式" tabindex="0" loading="lazy"><figcaption>依赖注入的实现方式</figcaption></figure>`,53)]))}const r=s(t,[["render",e]]),d=JSON.parse('{"path":"/posts/SpringBoot/Spring%E6%A1%86%E6%9E%B6.html","title":"Spring 框架","lang":"zh-CN","frontmatter":{"title":"Spring 框架","order":2,"category":["SpringBoot"],"tag":["SpringBoot","后端"],"date":"2022-07-10T00:00:00.000Z","icon":"iconfont icon-bxl-spring-boot","description":"Spring 框架 正射与反射 正射与反射的概述 正射：正射就是在运行时就知道要操作的类是什么，并且可以使用 new 关键字来创建对象。 反射：反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 优点： 在程序运⾏过程中可以操作类对象，增加了程序的灵活性。 解耦，从而提高程序的可扩展性，提高代码的复用率，⽅便外...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring 框架\\",\\"image\\":[\\"http://101.43.49.28:9000/blog/单例模式的概述.png\\",\\"http://101.43.49.28:9000/blog/Spring的框架.png\\",\\"http://101.43.49.28:9000/blog/依赖注入例子.png\\",\\"http://101.43.49.28:9000/blog/IOC工作过程.png\\",\\"http://101.43.49.28:9000/blog/依赖注入的实现方式.png\\"],\\"datePublished\\":\\"2022-07-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-30T01:23:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.O\\"}]}"],["meta",{"property":"og:url","content":"https://blog.sylphy.me/posts/SpringBoot/Spring%E6%A1%86%E6%9E%B6.html"}],["meta",{"property":"og:title","content":"Spring 框架"}],["meta",{"property":"og:description","content":"Spring 框架 正射与反射 正射与反射的概述 正射：正射就是在运行时就知道要操作的类是什么，并且可以使用 new 关键字来创建对象。 反射：反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 优点： 在程序运⾏过程中可以操作类对象，增加了程序的灵活性。 解耦，从而提高程序的可扩展性，提高代码的复用率，⽅便外..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://101.43.49.28:9000/blog/单例模式的概述.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-30T01:23:37.000Z"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:tag","content":"SpringBoot"}],["meta",{"property":"article:published_time","content":"2022-07-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-30T01:23:37.000Z"}]]},"git":{"createdTime":1745976217000,"updatedTime":1745976217000,"contributors":[{"name":"Sylphy","username":"Sylphy","email":"sylphy.me@foxmail.com","commits":1,"url":"https://github.com/Sylphy"}]},"readingTime":{"minutes":14.06,"words":4219},"filePathRelative":"posts/SpringBoot/Spring框架.md","excerpt":"\\n<h2>正射与反射</h2>\\n<hr>\\n<h3>正射与反射的概述</h3>\\n<ul>\\n<li>正射：正射就是在运行时就知道要操作的类是什么，并且可以使用 new 关键字来创建对象。</li>\\n<li>反射：反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。\\n<ul>\\n<li>优点：\\n<ol>\\n<li>在程序运⾏过程中可以操作类对象，增加了程序的灵活性。</li>\\n<li>解耦，从而提高程序的可扩展性，提高代码的复用率，⽅便外部调用。</li>\\n<li>对于任何⼀个类，当知道它的类名后，就能够知道这个类的所有属性和⽅法；⽽对于任何⼀个对象，都能够调⽤它的⼀个任意⽅法。</li>\\n</ol>\\n</li>\\n<li>缺点：\\n<ol>\\n<li>性能问题：Java 反射中包含了⼀些动态类型，JVM ⽆法对这些动态代码进⾏优化，因此通过反射来操作的⽅式要⽐正常操作效率更低。</li>\\n<li>安全问题：使⽤反射时要求程序必须在⼀个没有安全限制的环境中运⾏，如果程序有安全限制，就不能使用反射。</li>\\n<li>程序健壮性：反射允许代码执⾏⼀些平常不被允许的操作，破坏了程序结构的抽象性，导致平台发⽣变化时抽象的逻辑结构⽆法被识别。</li>\\n</ol>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{r as comp,d as data};
